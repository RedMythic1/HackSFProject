# BEST Trading Strategy - Iteration 2
# User Input (Original): if stock goes 1% up buy, .5% down sell...
# User Input (Enhanced by LLM): If the stock price increases by 1% from the entry point, enter a long position (buy). If the stock price decreases by 0.5% from the entry point, exit the position (sell)....
# Profit: $756114.43
# Buy & Hold Profit: $128652808.40
# Performance vs Buy & Hold: -99.41%
# Performance vs Target: -99.61%

# --- Full LLM Prompt Used for This Strategy --- #

**Your Role:** You are a specialized Python code generation assistant. Your sole task is to generate *exactly* two Python functions based on the user\'s strategy, following the strict rules below.

**User Strategy:** If the stock price increases by 1% from the entry point, enter a long position (buy). If the stock price decreases by 0.5% from the entry point, exit the position (sell).

**IMPROVEMENT CONTEXT:** 

**PREVIOUS ITERATION PERFORMANCE:**
- Previous Profit: $298226.87 (vs Buy & Hold: -80.33%)
- Target Profit: $2274011.27
- Performance vs Target: -86.89%

**IMPROVEMENT SUGGESTIONS:**
**Analysis**

- The current strategy rarely triggers (only 10 buy/sell points), suggesting thresholds are too restrictive for the volatility of the price series.
- The exit threshold (-0.5%) is tight, likely causing frequent small losses or missed larger gains if the price recovers after a minor dip.
- The profit is dramatically lower than buy & hold, indicating the strategy is missing out on large upward trends and possibly getting whipsawed.
- The 1% buy trigger might be too conservative, entering after significant movement and missing optimal entry points.

**Improvement Suggestions**

- Lower the long entry threshold from +1% to **+0.5%** from the entry point to increase trigger frequency and capture earlier momentum.
- Loosen the exit threshold from -0.5% to **-1.0%** to allow positions more room to recover from minor pullbacks, reducing premature exits.
- Add a **trailing stop**: Once a position is up by +2% from entry, set a trailing stop at +0.5% below the peak price since entry. This locks in gains on strong moves without exiting too early on small dips.
- Allow **re-entry**: If a position is exited, permit immediate re-entry if the buy condition is met again, to avoid sitting out of strong trends due to a single pullback.
- Ensure only one position is open at any time (if not already enforced), to avoid overlapping trades and confusion in P&L tracking.

These tweaks preserve the original logic but make the system more responsive and less likely to exit on noise, potentially boosting profitability without major structural changes.

Based on the above analysis, implement these improvements in your trading strategy to achieve the target profit of $2274011.27.


**DATA INFORMATION:**
- The data is loaded from a CSV file at 'stockbt/datasets/test.csv'
- CSV Format: Date,Open,High,Low,Close,Volume
- In the code, only the Close prices are available as a simple Python list named 'close'
- No DataFrame or pandas is used - data is just a plain Python list of float values
- You DO NOT need to load the data yourself - it\'s already available as 'close'

**CODE TEMPLATE GUIDELINES:**

1. Use a TRADING_STRATEGY function that accepts PARAMS dict
2. Iterate over CLOSE prices: for i, price_today in enumerate(close)
3. Create BUY_POINTS and SELL_POINTS lists for trades
4. Return (profit_loss, buy_points, sell_points, balance_over_time)
5. Replace YOUR_BUY_CONDITION and YOUR_SELL_CONDITION with actual logic
6. Use params.get('key', default) to safely access parameters
7. NO input() calls or user prompting in any function
8. Use try/except blocks to handle potential errors

**Critical Output Requirements:**

1.  **Format:**
    *   Your entire response MUST be ONLY the Python code for the two functions.
    *   **ABSOLUTELY NO MARKDOWN:** Do not use ```python, ```, or any other markdown formatting.
    *   **NO Explanations** outside of the code itself: Do not add any prose before or after the functions.
    *   **Limited Comments Allowed:** Inside the functions, you MAY include concise comments or docstrings that explain the purpose of scale/ratio parameters, but avoid any other extraneous commentary.
    *   Separate the two functions with exactly ONE blank line.

2.  **Function 1: `trading_strategy`**
    *   Must be named exactly `trading_strategy`.
    *   Must accept **EXACTLY ONE** positional argument (e.g., `params`), which will be the output (tuple or dict) from `get_user_params`. Do **NOT** add extra parameters (such as `formatted_inp`, `data`, etc.).
    *   Must implement the user\'s trading strategy using the provided `params`.
    *   When determining buy/sell prices, you **MUST NOT** rely on hard-coded or absolute price values. Instead, compute them as a **multiplier of the current `price_today`** or other relative measures derived from `params` (e.g., `buy_price = price_today * params["buy_mult"]`). A minimum execution price of $0.01 will be enforced.
    *   Define necessary loop variables such as `i`, `price_today`, and any multiplier-derived `buy_price`/`sell_price` consistent with the strategy (note that `close` is available in the execution context).
    *   Must include the **MANDATORY TRADING LOGIC** block verbatim within its primary execution loop or logic.
    *   Must include realistic market execution features such as slippage, bid-ask spread, commissions/fees, and liquidity constraints.
    *   Must **return** exactly `balance - initial_balance, buy_points, sell_points, balance_over_time` in that order.

3.  **Function 2: `get_user_params`**
    *   Must be named exactly `get_user_params`.
    *   **ABSOLUTELY CRITICAL: THIS FUNCTION MUST *NEVER* PROMPT THE USER FOR INPUT (e.g., using `input()` or similar functions, printing messages to the console that ask for input). ANY FORM OF USER INTERACTION IS STRICTLY FORBIDDEN.** It must automatically determine or iteratively search for optimized numeric parameters relevant to the strategy.
    *   Must **return** the chosen numeric parameters as a single tuple or dictionary.
    *   Include realistic market execution parameters (slippage_pct, spread_pct, commission_per_share, min_commission, max_position_pct).
    *   **DO NOT** read files (e.g., CSVs) within this function.
    *   **DO NOT** hard-code absolute price thresholds; parameters should be relative scales/ratios or other dimensionless values.

4.  **Environment:**
    *   Assume `math` module is pre-imported and available. Do **NOT** add import statements.
    *   Assume a Python list named `close` containing the price data is available in the execution scope of `trading_strategy`.

5.  **Simplified Data Structure:** The price series is available as the global Python list named `close`. It\'s a simple list of floating-point values. Access elements with standard indexing: `close[i]` or iterate with `for i, price_today in enumerate(close):`. No pandas/DataFrame code is needed.

6.  **Character Set:** Your entire code must use ONLY standard ASCII characters. Avoid typographic quotes (\' \' \" \" ) or long dashes (â€”). Use straight quotes (\' \") and hyphens (-) instead.

7.  **Data Access:** The price series is available as the global list named `close`. **Do NOT** attempt to access data via dictionaries or DataFrames. Simply use `close[i]` or iterate with `for i, price_today in enumerate(close):`.

8.  **Key-Error Safety:** Your code should never raise `KeyError`. Reference only variables you explicitly define.

**MANDATORY TRADING LOGIC (Include and adapt this block inside `trading_strategy`):**
```python
initial_balance = 100000
balance = initial_balance
shares = 0
buy_points = []
sell_points = []
balance_over_time = [balance] # Record initial balance

# Market execution parameters (realistic market conditions)
slippage_pct = params.get('slippage_pct', 0.001)  # 0.1% slippage by default
spread_pct = params.get('spread_pct', 0.0005)  # 0.05% half-spread by default
commission_per_share = params.get('commission_per_share', 0.005)  # $0.005 per share
min_commission_per_trade = params.get('min_commission', 1.0)  # Minimum $1.00 per trade
max_position_pct_of_volume = params.get('max_position_pct', 0.01)  # Maximum 1% of volume

# --- Start of logic needing integration with your strategy loop ---
# You need a loop here (e.g., for i, price_today in enumerate(close):)
# Inside the loop, calculate buy/sell signals based on user_input strategy and params.

# Example Buy Logic (adapt to your strategy):
# if YOUR_BUY_CONDITION and shares == 0: # Only buy if no shares are held
#   # Apply bid-ask spread (buy at ask price = higher)
#   base_price = price_today * (1 + spread_pct)
#   # Apply slippage (price moves against you when executing)
#   buy_price_with_spread = base_price * (1 + slippage_pct)
#   # Ensure minimum price
#   buy_price = max(0.01, buy_price_with_spread * params.get('buy_price_multiplier', 0.99))
#   
#   # Apply liquidity constraint (limit position size)
#   daily_volume = params.get('avg_volume', 100000)  # Default or from params
#   max_shares_by_volume = int(daily_volume * max_position_pct_of_volume)
#   
#   # Calculate shares to buy considering price and liquidity
#   max_shares_by_cash = math.floor(balance / buy_price) if buy_price > 0 else 0
#   shares_to_buy = min(max_shares_by_cash, max_shares_by_volume)
#   
#   if shares_to_buy > 0:
#       # Calculate commission
#       commission = max(min_commission_per_trade, shares_to_buy * commission_per_share)
#       # Execute trade with commission
#       trade_cost = (shares_to_buy * buy_price) + commission
#       balance -= trade_cost
#       shares += shares_to_buy
#       buy_points.append((i, price_today)) # Record buy point (index, price at trade)
#       print(f"Bought [shares_to_buy] shares at [buy_price:.2f] with [commission:.2f] commission on day [i] (price: [price_today:.2f])")

# Example Sell Logic (adapt to your strategy):
# elif YOUR_SELL_CONDITION and shares > 0: # Only sell if shares are held
#   # Apply bid-ask spread (sell at bid price = lower)
#   base_price = price_today * (1 - spread_pct)
#   # Apply slippage (price moves against you when executing)
#   sell_price_with_spread = base_price * (1 - slippage_pct)
#   # Ensure minimum price
#   sell_price = max(0.01, sell_price_with_spread * params.get('sell_price_multiplier', 1.01))
#   
#   if shares > 0: # Check if shares are held before selling
#       # Calculate commission
#       commission = max(min_commission_per_trade, shares * commission_per_share)
#       # Execute trade with commission
#       sale_proceeds = (shares * sell_price) - commission
#       balance += sale_proceeds
#       sell_points.append((i, price_today)) # Record sell point (index, price at trade)
#       print(f"Sold [shares] shares at [sell_price:.2f] with [commission:.2f] commission on day [i] (price: [price_today:.2f[])")
#       shares = 0

# At the end of each iteration in your loop (after potential buy/sell):
# balance_over_time.append(balance + (shares * price_today if shares > 0 else 0)) # Append current total value

# After the loop, if shares are still held, liquidate them at the last known price
if shares > 0:
    # Apply bid-ask spread and slippage for final liquidation
    base_price = max(0.01, close[-1] if close else 0.01) * (1 - spread_pct)
    last_price = max(0.01, base_price * (1 - slippage_pct))
    # Calculate commission for final sale
    commission = max(min_commission_per_trade, shares * commission_per_share)
    # Execute final liquidation with commission
    sale_proceeds = (shares * last_price) - commission
    balance += sale_proceeds
    sell_points.append((len(close) -1, close[-1] if close else 0.01)) # Record final auto-sell
    print(f"Final liquidation: Sold [shares] shares at [last_price:.2f] with [commission:.2f] commission")
    shares = 0
balance_over_time.append(balance) # Append final balance state
return balance - initial_balance, buy_points, sell_points, balance_over_time
```
**(Note:** The MANDATORY TRADING LOGIC above is a template. You **must** integrate it correctly within the `trading_strategy` function\'s loop, defining variables like `i`, `price_today`, `buy_price`, `sell_price` according to the user\'s strategy and the parameters from `get_user_params`. The comments indicate where your strategy-specific logic needs to fit.)

**Final Check:** Ensure your output is only the two raw Python function definitions separated by a single blank line. No markdown, no comments outside the functions, no extra text.

**Important Output Format Requirements:**
- Your trading_strategy function may return its results in EITHER of these formats:
  1. Standard tuple: (profit_loss, buy_points, sell_points, balance_over_time)
  2. Dictionary format: {\'profit_loss\': profit_amount, \'buy_points\': [...], \'sell_points\': [...], \'balance_over_time\': [...]}

- The dictionary format is preferred as it\'s more explicit. For buy_points and sell_points, you can provide either:
  * A list of (index, price) tuples
  * A list of indices where trades occurred


# --- Generated Strategy Function --- #
def trading_strategy(params):
    """
    Implements improved momentum strategy:
Enter long if price rises +0.5% from entry reference (or from last exit if flat)
Exit if price falls -1.0% from entry price
Trailing stop: If price rises +2% from entry, set trailing stop at +0.5% below peak since entry
Allow immediate re-entry after exit if buy condition met
Only one position at a time
Realistic execution: slippage, spread, commission, liquidity
    """
    initial_balance = 100000
    balance = initial_balance
    shares = 0
    buy_points = []
    sell_points = []
    balance_over_time = [balance]
    slippage_pct = params.get('slippage_pct', 0.001)
    spread_pct = params.get('spread_pct', 0.0005)
    commission_per_share = params.get('commission_per_share', 0.005)
    min_commission_per_trade = params.get('min_commission', 1.0)
    max_position_pct_of_volume = params.get('max_position_pct', 0.01)
    avg_volume = params.get('avg_volume', 100000)
    buy_trigger = params.get('buy_trigger', 0.005)  # +0.5%
    sell_trigger = params.get('sell_trigger', -0.01)  # -1.0%
    trailing_trigger = params.get('trailing_trigger', 0.02)  # +2%
    trailing_stop_gap = params.get('trailing_stop_gap', 0.005)  # 0.5%
    buy_price_multiplier = params.get('buy_price_multiplier', 0.99)
    sell_price_multiplier = params.get('sell_price_multiplier', 1.01)
    entry_price = None
    entry_index = None
    peak_price = None
    trailing_stop = None
    in_position = False
    try:
        for i, price_today in enumerate(close):
            # If not in position, look for buy trigger
            if not in_position:
                if entry_price is None:
                    entry_price = price_today
                    entry_index = i
                    peak_price = price_today
                    trailing_stop = None
                price_change = (price_today - entry_price) / entry_price
                if price_change >= buy_trigger:
                    # Buy logic
                    base_price = price_today * (1 + spread_pct)
                    buy_price_with_spread = base_price * (1 + slippage_pct)
                    buy_price = max(0.01, buy_price_with_spread * buy_price_multiplier)
                    daily_volume = avg_volume
                    max_shares_by_volume = int(daily_volume * max_position_pct_of_volume)
                    max_shares_by_cash = math.floor(balance / buy_price) if buy_price > 0 else 0
                    shares_to_buy = min(max_shares_by_cash, max_shares_by_volume)
                    if shares_to_buy > 0:
                        commission = max(min_commission_per_trade, shares_to_buy * commission_per_share)
                        trade_cost = (shares_to_buy * buy_price) + commission
                        balance -= trade_cost
                        shares += shares_to_buy
                        buy_points.append((i, price_today))
                        in_position = True
                        entry_price = buy_price  # Use executed price as entry
                        entry_index = i
                        peak_price = price_today
                        trailing_stop = None
            else:
                # In position: update peak, check for trailing stop, check for exit
                if price_today > peak_price:
                    peak_price = price_today
                price_change = (price_today - entry_price) / entry_price
                # Activate trailing stop if price up > trailing_trigger
                if price_change >= trailing_trigger:
                    trailing_stop = peak_price * (1 - trailing_stop_gap)
                # Exit if price falls below trailing stop (if set) or below sell_trigger
                sell_signal = False
                if trailing_stop is not None and price_today <= trailing_stop:
                    sell_signal = True
                elif (price_today - entry_price) / entry_price <= sell_trigger:
                    sell_signal = True
                if sell_signal:
                    base_price = price_today * (1 - spread_pct)
                    sell_price_with_spread = base_price * (1 - slippage_pct)
                    sell_price = max(0.01, sell_price_with_spread * sell_price_multiplier)
                    if shares > 0:
                        commission = max(min_commission_per_trade, shares * commission_per_share)
                        sale_proceeds = (shares * sell_price) - commission
                        balance += sale_proceeds
                        sell_points.append((i, price_today))
                        shares = 0
                        in_position = False
                        entry_price = price_today  # Reset reference for next entry
                        entry_index = i
                        peak_price = price_today
                        trailing_stop = None
            balance_over_time.append(balance + (shares * price_today if shares > 0 else 0))
        # Final liquidation if holding shares
        if shares > 0:
            base_price = max(0.01, close[-1] if close else 0.01) * (1 - spread_pct)
            last_price = max(0.01, base_price * (1 - slippage_pct))
            commission = max(min_commission_per_trade, shares * commission_per_share)
            sale_proceeds = (shares * last_price) - commission
            balance += sale_proceeds
            sell_points.append((len(close) -1, close[-1] if close else 0.01))
            shares = 0
        balance_over_time.append(balance)
        return {
            'profit_loss': balance - initial_balance,
            'buy_points': buy_points,
            'sell_points': sell_points,
            'balance_over_time': balance_over_time
        }
    except Exception as e:
        return {
            'profit_loss': 0,
            'buy_points': [],
            'sell_points': [],
            'balance_over_time': [initial_balance],
            'error': str(e)
        }

# --- Generated Parameters Function --- #
def get_user_params():
    """
    Returns optimized parameters for improved momentum/trailing stop strategy.
    All thresholds are relative ratios (not absolute prices).
    """
    return {
        'buy_trigger': 0.005,           # +0.5% from reference price to buy
        'sell_trigger': -0.01,          # -1.0% from entry price to sell
        'trailing_trigger': 0.02,       # +2.0% from entry to activate trailing stop
        'trailing_stop_gap': 0.005,     # Trailing stop is 0.5% below peak since entry
        'slippage_pct': 0.001,          # 0.1% slippage
        'spread_pct': 0.0005,           # 0.05% half-spread
        'commission_per_share': 0.005,  # $0.005 per share
        'min_commission': 1.0,          # $1 minimum commission per trade
        'max_position_pct': 0.01,       # Max 1% of daily volume per trade
        'avg_volume': 100000,           # Estimated average daily volume
        'buy_price_multiplier': 0.99,   # Slightly favor better entry execution
        'sell_price_multiplier': 1.01   # Slightly favor better exit execution
    }