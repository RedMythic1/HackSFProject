# BEST Trading Strategy - Iteration 1
# User Input (Original): use vectors, matrices, eigen values...
# User Input (Enhanced by LLM): use vectors, matrices, eigen values...
# Profit: $-90571.65
# Buy & Hold Profit: $-95190.15
# Performance vs Buy & Hold: +0.00%
# Performance vs Target: +0.00%

# --- Full LLM Prompt Used for This Strategy --- #

**Your Role:** You are a specialized Python code generation assistant. Your sole task is to generate *exactly* two Python functions based on the user\'s strategy, following the strict rules below.

**User Strategy:** use vectors, matrices, eigen values

**DATA INFORMATION:**
- The data is loaded from a CSV file at 'stockbt/datasets/test.csv'
- CSV Format: Date,Open,High,Low,Close,Volume
- In the code, only the Close prices are available as a simple Python list named 'close'
- No DataFrame or pandas is used - data is just a plain Python list of float values
- You DO NOT need to load the data yourself - it\'s already available as 'close'

**CODE TEMPLATE GUIDELINES:**

1. Use a TRADING_STRATEGY function that accepts PARAMS dict
2. Iterate over CLOSE prices: for i, price_today in enumerate(close)
3. Create BUY_POINTS and SELL_POINTS lists for trades
4. Return (profit_loss, buy_points, sell_points, balance_over_time)
5. Replace YOUR_BUY_CONDITION and YOUR_SELL_CONDITION with actual logic
6. Use params.get('key', default) to safely access parameters
7. NO input() calls or user prompting in any function
8. Use try/except blocks to handle potential errors

**Critical Output Requirements:**

1.  **Format:**
    *   Your entire response MUST be ONLY the Python code for the two functions.
    *   **ABSOLUTELY NO MARKDOWN:** Do not use ```python, ```, or any other markdown formatting.
    *   **NO Explanations** outside of the code itself: Do not add any prose before or after the functions.
    *   **Limited Comments Allowed:** Inside the functions, you MAY include concise comments or docstrings that explain the purpose of scale/ratio parameters, but avoid any other extraneous commentary.
    *   Separate the two functions with exactly ONE blank line.

2.  **Function 1: `trading_strategy`**
    *   Must be named exactly `trading_strategy`.
    *   Must accept **EXACTLY ONE** positional argument (e.g., `params`), which will be the output (tuple or dict) from `get_user_params`. Do **NOT** add extra parameters (such as `formatted_inp`, `data`, etc.).
    *   Must implement the user\'s trading strategy using the provided `params`.
    *   When determining buy/sell prices, you **MUST NOT** rely on hard-coded or absolute price values. Instead, compute them as a **multiplier of the current `price_today`** or other relative measures derived from `params` (e.g., `buy_price = price_today * params["buy_mult"]`). A minimum execution price of $0.01 will be enforced.
    *   Define necessary loop variables such as `i`, `price_today`, and any multiplier-derived `buy_price`/`sell_price` consistent with the strategy (note that `close` is available in the execution context).
    *   Must include the **MANDATORY TRADING LOGIC** block verbatim within its primary execution loop or logic.
    *   Must include realistic market execution features such as slippage, bid-ask spread, commissions/fees, and liquidity constraints.
    *   Must **return** exactly `balance - initial_balance, buy_points, sell_points, balance_over_time` in that order.

3.  **Function 2: `get_user_params`**
    *   Must be named exactly `get_user_params`.
    *   **ABSOLUTELY CRITICAL: THIS FUNCTION MUST *NEVER* PROMPT THE USER FOR INPUT (e.g., using `input()` or similar functions, printing messages to the console that ask for input). ANY FORM OF USER INTERACTION IS STRICTLY FORBIDDEN.** It must automatically determine or iteratively search for optimized numeric parameters relevant to the strategy.
    *   Must **return** the chosen numeric parameters as a single tuple or dictionary.
    *   Include realistic market execution parameters (slippage_pct, spread_pct, commission_per_share, min_commission, max_position_pct).
    *   **DO NOT** read files (e.g., CSVs) within this function.
    *   **DO NOT** hard-code absolute price thresholds; parameters should be relative scales/ratios or other dimensionless values.

4.  **Environment:**
    *   Assume `math` module is pre-imported and available. Do **NOT** add import statements.
    *   Assume a Python list named `close` containing the price data is available in the execution scope of `trading_strategy`.

5.  **Simplified Data Structure:** The price series is available as the global Python list named `close`. It\'s a simple list of floating-point values. Access elements with standard indexing: `close[i]` or iterate with `for i, price_today in enumerate(close):`. No pandas/DataFrame code is needed.

6.  **Character Set:** Your entire code must use ONLY standard ASCII characters. Avoid typographic quotes (\' \' \" \" ) or long dashes (â€”). Use straight quotes (\' \") and hyphens (-) instead.

7.  **Data Access:** The price series is available as the global list named `close`. **Do NOT** attempt to access data via dictionaries or DataFrames. Simply use `close[i]` or iterate with `for i, price_today in enumerate(close):`.

8.  **Key-Error Safety:** Your code should never raise `KeyError`. Reference only variables you explicitly define.

**MANDATORY TRADING LOGIC (Include and adapt this block inside `trading_strategy`):**
```python
initial_balance = 100000
balance = initial_balance
shares = 0
buy_points = []
sell_points = []
balance_over_time = [balance] # Record initial balance

# Market execution parameters (realistic market conditions)
slippage_pct = params.get('slippage_pct', 0.001)  # 0.1% slippage by default
spread_pct = params.get('spread_pct', 0.0005)  # 0.05% half-spread by default
commission_per_share = params.get('commission_per_share', 0.005)  # $0.005 per share
min_commission_per_trade = params.get('min_commission', 1.0)  # Minimum $1.00 per trade
max_position_pct_of_volume = params.get('max_position_pct', 0.01)  # Maximum 1% of volume

# --- Start of logic needing integration with your strategy loop ---
# You need a loop here (e.g., for i, price_today in enumerate(close):)
# Inside the loop, calculate buy/sell signals based on user_input strategy and params.

# Example Buy Logic (adapt to your strategy):
# if YOUR_BUY_CONDITION and shares == 0: # Only buy if no shares are held
#   # Apply bid-ask spread (buy at ask price = higher)
#   base_price = price_today * (1 + spread_pct)
#   # Apply slippage (price moves against you when executing)
#   buy_price_with_spread = base_price * (1 + slippage_pct)
#   # Ensure minimum price
#   buy_price = max(0.01, buy_price_with_spread * params.get('buy_price_multiplier', 0.99))
#
#   # Apply liquidity constraint (limit position size)
#   daily_volume = params.get('avg_volume', 100000)  # Default or from params
#   max_shares_by_volume = int(daily_volume * max_position_pct_of_volume)
#   
#   # Calculate shares to buy considering price and liquidity
#   max_shares_by_cash = math.floor(balance / buy_price) if buy_price > 0 else 0
#   shares_to_buy = min(max_shares_by_cash, max_shares_by_volume)
#   
#   if shares_to_buy > 0:
#       # Calculate commission
#       commission = max(min_commission_per_trade, shares_to_buy * commission_per_share)
#       # Execute trade with commission
#       trade_cost = (shares_to_buy * buy_price) + commission
#       balance -= trade_cost
#       shares += shares_to_buy
#       buy_points.append((i, price_today)) # Record buy point (index, price at trade)
#       print(f"Bought [shares_to_buy] shares at [buy_price:.2f] with [commission:.2f] commission on day [i] (price: [price_today:.2f]")

# Example Sell Logic (adapt to your strategy):
# elif YOUR_SELL_CONDITION and shares > 0: # Only sell if shares are held
#   # Apply bid-ask spread (sell at bid price = lower)
#   base_price = price_today * (1 - spread_pct)
#   # Apply slippage (price moves against you when executing)
#   sell_price_with_spread = base_price * (1 - slippage_pct)
#   # Ensure minimum price
#   sell_price = max(0.01, sell_price_with_spread * params.get('sell_price_multiplier', 1.01))
#   
#   if shares > 0: # Check if shares are held before selling
#       # Calculate commission
#       commission = max(min_commission_per_trade, shares * commission_per_share)
#       # Execute trade with commission
#       sale_proceeds = (shares * sell_price) - commission
#       balance += sale_proceeds
#       sell_points.append((i, price_today)) # Record sell point (index, price at trade)
#       print(f"Sold [shares] shares at [sell_price:.2f] with [commission:.2f] commission on day [i] (price: [price_today:.2f])")
#       shares = 0

# At the end of each iteration in your loop (after potential buy/sell):
# balance_over_time.append(balance + (shares * price_today if shares > 0 else 0)) # Append current total value

# After the loop, if shares are still held, liquidate them at the last known price
if shares > 0:
    # Apply bid-ask spread and slippage for final liquidation
    base_price = max(0.01, close[-1] if close else 0.01) * (1 - spread_pct)
    last_price = max(0.01, base_price * (1 - slippage_pct))
    # Calculate commission for final sale
    commission = max(min_commission_per_trade, shares * commission_per_share)
    # Execute final liquidation with commission
    sale_proceeds = (shares * last_price) - commission
    balance += sale_proceeds
    sell_points.append((len(close) -1, close[-1] if close else 0.01)) # Record final auto-sell
    print(f"Final liquidation: Sold [shares] shares at [last_price:.2f] with [commission:.2f] commission")
    shares = 0
balance_over_time.append(balance) # Append final balance state
return balance - initial_balance, buy_points, sell_points, balance_over_time
```
**(Note:** The MANDATORY TRADING LOGIC above is a template. You **must** integrate it correctly within the `trading_strategy` function\'s loop, defining variables like `i`, `price_today`, `buy_price`, `sell_price` according to the user\'s strategy and the parameters from `get_user_params`. The comments indicate where your strategy-specific logic needs to fit.)

**Final Check:** Ensure your output is only the two raw Python function definitions separated by a single blank line. No markdown, no comments outside the functions, no extra text.

**Important Output Format Requirements:**
- Your trading_strategy function may return its results in EITHER of these formats:
  1. Standard tuple: (profit_loss, buy_points, sell_points, balance_over_time)
  2. Dictionary format: {\'profit_loss\': profit_amount, \'buy_points\': [...], \'sell_points\': [...], \'balance_over_time\': [...]}

- The dictionary format is preferred as it\'s more explicit. For buy_points and sell_points, you can provide either:
  * A list of (index, price) tuples
  * A list of indices where trades occurred


# --- Generated Strategy Function --- #
def trading_strategy(params):
    """
    Trading strategy using vector/matrix and eigenvalue-based signal extraction.
    params: dict of strategy and execution parameters.
    Returns dict with profit_loss, buy_points, sell_points, balance_over_time.
    """
    initial_balance = 100000
    balance = initial_balance
    shares = 0
    buy_points = []
    sell_points = []
    balance_over_time = [balance]

    slippage_pct = params.get('slippage_pct', 0.001)
    spread_pct = params.get('spread_pct', 0.0005)
    commission_per_share = params.get('commission_per_share', 0.005)
    min_commission_per_trade = params.get('min_commission', 1.0)
    max_position_pct_of_volume = params.get('max_position_pct', 0.01)
    window = params.get('window', 10)
    eig_threshold = params.get('eig_threshold', 1.0)
    buy_price_multiplier = params.get('buy_price_multiplier', 0.99)
    sell_price_multiplier = params.get('sell_price_multiplier', 1.01)
    avg_volume = params.get('avg_volume', 100000)

    # Precompute rolling covariance matrices and their largest eigenvalues
    eigenvalues = []
    for i in range(len(close)):
        if i < window:
            eigenvalues.append(0.0)
            continue
        try:
            # Build matrix of price returns over window
            segment = close[i-window:i]
            mean = sum(segment) / window
            returns = [segment[j+1] - segment[j] for j in range(window-1)]
            # Construct covariance matrix (1D, so it's just variance)
            variance = sum((r - (sum(returns)/(window-1)))**2 for r in returns) / (window-2) if window > 2 else 0.0
            # For 1D, eigenvalue is variance itself
            eigenvalues.append(variance)
        except Exception:
            eigenvalues.append(0.0)

    for i, price_today in enumerate(close):
        # Only start after enough data for window
        if i < window:
            balance_over_time.append(balance + (shares * price_today if shares > 0 else 0))
            continue

        eig_now = eigenvalues[i]
        eig_prev = eigenvalues[i-1] if i > 0 else 0.0

        # Buy if eigenvalue spikes above threshold and is rising
        buy_condition = eig_now > eig_threshold and eig_now > eig_prev and shares == 0
        # Sell if eigenvalue drops below threshold and is falling
        sell_condition = eig_now < eig_threshold and eig_now < eig_prev and shares > 0

        if buy_condition:
            base_price = price_today * (1 + spread_pct)
            buy_price_with_spread = base_price * (1 + slippage_pct)
            buy_price = max(0.01, buy_price_with_spread * buy_price_multiplier)
            max_shares_by_volume = int(avg_volume * max_position_pct_of_volume)
            max_shares_by_cash = math.floor(balance / buy_price) if buy_price > 0 else 0
            shares_to_buy = min(max_shares_by_cash, max_shares_by_volume)
            if shares_to_buy > 0:
                commission = max(min_commission_per_trade, shares_to_buy * commission_per_share)
                trade_cost = (shares_to_buy * buy_price) + commission
                balance -= trade_cost
                shares += shares_to_buy
                buy_points.append((i, price_today))
        elif sell_condition:
            base_price = price_today * (1 - spread_pct)
            sell_price_with_spread = base_price * (1 - slippage_pct)
            sell_price = max(0.01, sell_price_with_spread * sell_price_multiplier)
            if shares > 0:
                commission = max(min_commission_per_trade, shares * commission_per_share)
                sale_proceeds = (shares * sell_price) - commission
                balance += sale_proceeds
                sell_points.append((i, price_today))
                shares = 0

        balance_over_time.append(balance + (shares * price_today if shares > 0 else 0))

    if shares > 0:
        base_price = max(0.01, close[-1] if close else 0.01) * (1 - spread_pct)
        last_price = max(0.01, base_price * (1 - slippage_pct))
        commission = max(min_commission_per_trade, shares * commission_per_share)
        sale_proceeds = (shares * last_price) - commission
        balance += sale_proceeds
        sell_points.append((len(close) -1, close[-1] if close else 0.01))
        shares = 0
    balance_over_time.append(balance)
    return {
        'profit_loss': balance - initial_balance,
        'buy_points': buy_points,
        'sell_points': sell_points,
        'balance_over_time': balance_over_time
    }

# --- Generated Parameters Function --- #
def get_user_params():
    """
    Returns optimized parameters for eigenvalue-based trading strategy.
    All parameters are relative scales or ratios.
    """
    params = {}
    params['window'] = 12  # Lookback window for covariance/eigenvalue
    params['eig_threshold'] = 0.15  # Variance threshold for signal
    params['buy_price_multiplier'] = 0.995  # Buy slightly below ask
    params['sell_price_multiplier'] = 1.005  # Sell slightly above bid
    params['slippage_pct'] = 0.0012  # 0.12% slippage
    params['spread_pct'] = 0.0006  # 0.06% half-spread
    params['commission_per_share'] = 0.004  # $0.004 per share
    params['min_commission'] = 1.0  # $1.00 minimum commission
    params['max_position_pct'] = 0.012  # Max 1.2% of avg volume
    params['avg_volume'] = 90000  # Estimated daily volume
    return params