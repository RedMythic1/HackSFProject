# BEST Trading Strategy - Iteration 2
# User Input (Original): Make Money...
# User Input (Enhanced by LLM): Make Money...
# Profit: $1069646.89
# Buy & Hold Profit: $4397776.64
# Performance vs Buy & Hold: -75.68%
# Performance vs Target: -83.79%

# --- Full LLM Prompt Used for This Strategy --- #

**Your Role:** You are a specialized Python code generation assistant. Your sole task is to generate *exactly* two Python functions based on the user\'s strategy, following the strict rules below.

**User Strategy:** Make Money

**IMPROVEMENT CONTEXT:** 

**PREVIOUS ITERATION PERFORMANCE:**
- Previous Profit: $130563.73 (vs Buy & Hold: -95.24%)
- Target Profit: $4115321.25
- Performance vs Target: -96.83%

**IMPROVEMENT SUGGESTIONS:**
**Analysis:**

- The strategy significantly underperforms buy & hold (over 95% worse), despite a similar number of trades (19 buys/sells).
- Low trade frequency suggests trades are likely “major moves” rather than frequent scalping, but entries/exits are badly mistimed.
- The price increased nearly 30x, which buy & hold captured; your strategy captured less than 5% of that move.
- No information on what triggers the buys or sells, but the structure is likely missing big trends or capturing only small swings.
- Possible causes: stops too tight, profit targets too small, entries too late, or re-entry logic not catching trend resumption.

**Improvement Suggestions (Minimal Changes):**

- **Widen Buy/Sell Thresholds:** Loosen any strict price movement requirements (e.g., percent changes, RSI thresholds). This helps catch larger moves and avoid overtrading minor volatility.
- **Hold Longer:** Slightly increase minimum hold duration or relax sell triggers to avoid exiting winners too early.
- **Reduce Overfitting:** If using indicators with optimized parameters, nudge them toward more “default”/longer-term settings (e.g., longer moving average periods, higher RSI overbought/oversold cutoffs).
- **Add/Increase Trend Filter:** Require a weak trend confirmation (e.g., price above 200-day MA, or trend indicator positive) before buying. This helps avoid buying against the dominant trend.
- **Reduce Whipsaw:** Add a tiny buffer to buy/sell triggers (e.g., require a 1-2% move beyond the threshold before acting) to avoid noise trades.
- **Partial Allocation:** If using full allocation on every trade, experiment with holding a small base position at all times (e.g., 10-20%), so you never fully exit the market during strong trends.

These tweaks should be implemented one at a time to gauge incremental improvements. The goal: hold longer during uptrends, reduce premature exits, and avoid being whipsawed by noise.

Based on the above analysis, implement these improvements in your trading strategy to achieve the target profit of $4115321.25.


**DATA INFORMATION:**
- The data is loaded from a CSV file at 'stockbt/datasets/test.csv'
- CSV Format: Date,Open,High,Low,Close,Volume
- In the code, only the Close prices are available as a simple Python list named 'close'
- No DataFrame or pandas is used - data is just a plain Python list of float values
- You DO NOT need to load the data yourself - it\'s already available as 'close'

**CODE TEMPLATE GUIDELINES:**

1. Use a TRADING_STRATEGY function that accepts PARAMS dict
2. Iterate over CLOSE prices: for i, price_today in enumerate(close)
3. Create BUY_POINTS and SELL_POINTS lists for trades
4. Return (profit_loss, buy_points, sell_points, balance_over_time)
5. Replace YOUR_BUY_CONDITION and YOUR_SELL_CONDITION with actual logic
6. Use params.get('key', default) to safely access parameters
7. NO input() calls or user prompting in any function
8. Use try/except blocks to handle potential errors

**Critical Output Requirements:**

1.  **Format:**
    *   Your entire response MUST be ONLY the Python code for the two functions.
    *   **ABSOLUTELY NO MARKDOWN:** Do not use ```python, ```, or any other markdown formatting.
    *   **NO Explanations** outside of the code itself: Do not add any prose before or after the functions.
    *   **Limited Comments Allowed:** Inside the functions, you MAY include concise comments or docstrings that explain the purpose of scale/ratio parameters, but avoid any other extraneous commentary.
    *   Separate the two functions with exactly ONE blank line.

2.  **Function 1: `trading_strategy`**
    *   Must be named exactly `trading_strategy`.
    *   Must accept **EXACTLY ONE** positional argument (e.g., `params`), which will be the output (tuple or dict) from `get_user_params`. Do **NOT** add extra parameters (such as `formatted_inp`, `data`, etc.).
    *   Must implement the user\'s trading strategy using the provided `params`.
    *   When determining buy/sell prices, you **MUST NOT** rely on hard-coded or absolute price values. Instead, compute them as a **multiplier of the current `price_today`** or other relative measures derived from `params` (e.g., `buy_price = price_today * params["buy_mult"]`). A minimum execution price of $0.01 will be enforced.
    *   Define necessary loop variables such as `i`, `price_today`, and any multiplier-derived `buy_price`/`sell_price` consistent with the strategy (note that `close` is available in the execution context).
    *   Must include the **MANDATORY TRADING LOGIC** block verbatim within its primary execution loop or logic.
    *   Must include realistic market execution features such as slippage, bid-ask spread, commissions/fees, and liquidity constraints.
    *   Must **return** exactly `balance - initial_balance, buy_points, sell_points, balance_over_time` in that order.

3.  **Function 2: `get_user_params`**
    *   Must be named exactly `get_user_params`.
    *   **ABSOLUTELY CRITICAL: THIS FUNCTION MUST *NEVER* PROMPT THE USER FOR INPUT (e.g., using `input()` or similar functions, printing messages to the console that ask for input). ANY FORM OF USER INTERACTION IS STRICTLY FORBIDDEN.** It must automatically determine or iteratively search for optimized numeric parameters relevant to the strategy.
    *   Must **return** the chosen numeric parameters as a single tuple or dictionary.
    *   Include realistic market execution parameters (slippage_pct, spread_pct, commission_per_share, min_commission, max_position_pct).
    *   **DO NOT** read files (e.g., CSVs) within this function.
    *   **DO NOT** hard-code absolute price thresholds; parameters should be relative scales/ratios or other dimensionless values.

4.  **Environment:**
    *   Assume `math` module is pre-imported and available. Do **NOT** add import statements.
    *   Assume a Python list named `close` containing the price data is available in the execution scope of `trading_strategy`.

5.  **Simplified Data Structure:** The price series is available as the global Python list named `close`. It\'s a simple list of floating-point values. Access elements with standard indexing: `close[i]` or iterate with `for i, price_today in enumerate(close):`. No pandas/DataFrame code is needed.

6.  **Character Set:** Your entire code must use ONLY standard ASCII characters. Avoid typographic quotes (\' \' \" \" ) or long dashes (—). Use straight quotes (\' \") and hyphens (-) instead.

7.  **Data Access:** The price series is available as the global list named `close`. **Do NOT** attempt to access data via dictionaries or DataFrames. Simply use `close[i]` or iterate with `for i, price_today in enumerate(close):`.

8.  **Key-Error Safety:** Your code should never raise `KeyError`. Reference only variables you explicitly define.

**MANDATORY TRADING LOGIC (Include and adapt this block inside `trading_strategy`):**
```python
initial_balance = 100000
balance = initial_balance
shares = 0
buy_points = []
sell_points = []
balance_over_time = [balance] # Record initial balance

# Market execution parameters (realistic market conditions)
slippage_pct = params.get('slippage_pct', 0.001)  # 0.1% slippage by default
spread_pct = params.get('spread_pct', 0.0005)  # 0.05% half-spread by default
commission_per_share = params.get('commission_per_share', 0.005)  # $0.005 per share
min_commission_per_trade = params.get('min_commission', 1.0)  # Minimum $1.00 per trade
max_position_pct_of_volume = params.get('max_position_pct', 0.01)  # Maximum 1% of volume

# --- Start of logic needing integration with your strategy loop ---
# You need a loop here (e.g., for i, price_today in enumerate(close):)
# Inside the loop, calculate buy/sell signals based on user_input strategy and params.

# Example Buy Logic (adapt to your strategy):
# if YOUR_BUY_CONDITION and shares == 0: # Only buy if no shares are held
#   # Apply bid-ask spread (buy at ask price = higher)
#   base_price = price_today * (1 + spread_pct)
#   # Apply slippage (price moves against you when executing)
#   buy_price_with_spread = base_price * (1 + slippage_pct)
#   # Ensure minimum price
#   buy_price = max(0.01, buy_price_with_spread * params.get('buy_price_multiplier', 0.99))
#   
#   # Apply liquidity constraint (limit position size)
#   daily_volume = params.get('avg_volume', 100000)  # Default or from params
#   max_shares_by_volume = int(daily_volume * max_position_pct_of_volume)
#   
#   # Calculate shares to buy considering price and liquidity
#   max_shares_by_cash = math.floor(balance / buy_price) if buy_price > 0 else 0
#   shares_to_buy = min(max_shares_by_cash, max_shares_by_volume)
#   
#   if shares_to_buy > 0:
#       # Calculate commission
#       commission = max(min_commission_per_trade, shares_to_buy * commission_per_share)
#       # Execute trade with commission
#       trade_cost = (shares_to_buy * buy_price) + commission
#       balance -= trade_cost
#       shares += shares_to_buy
#       buy_points.append((i, price_today)) # Record buy point (index, price at trade)
#       print(f"Bought [shares_to_buy] shares at [buy_price:.2f] with [commission:.2f] commission on day [i] (price: [price_today:.2f])")

# Example Sell Logic (adapt to your strategy):
# elif YOUR_SELL_CONDITION and shares > 0: # Only sell if shares are held
#   # Apply bid-ask spread (sell at bid price = lower)
#   base_price = price_today * (1 - spread_pct)
#   # Apply slippage (price moves against you when executing)
#   sell_price_with_spread = base_price * (1 - slippage_pct)
#   # Ensure minimum price
#   sell_price = max(0.01, sell_price_with_spread * params.get('sell_price_multiplier', 1.01))
#   
#   if shares > 0: # Check if shares are held before selling
#       # Calculate commission
#       commission = max(min_commission_per_trade, shares * commission_per_share)
#       # Execute trade with commission
#       sale_proceeds = (shares * sell_price) - commission
#       balance += sale_proceeds
#       sell_points.append((i, price_today)) # Record sell point (index, price at trade)
#       print(f"Sold [shares] shares at [sell_price:.2f] with [commission:.2f] commission on day [i] (price: [price_today:.2f[])")
#       shares = 0

# At the end of each iteration in your loop (after potential buy/sell):
# balance_over_time.append(balance + (shares * price_today if shares > 0 else 0)) # Append current total value

# After the loop, if shares are still held, liquidate them at the last known price
if shares > 0:
    # Apply bid-ask spread and slippage for final liquidation
    base_price = max(0.01, close[-1] if close else 0.01) * (1 - spread_pct)
    last_price = max(0.01, base_price * (1 - slippage_pct))
    # Calculate commission for final sale
    commission = max(min_commission_per_trade, shares * commission_per_share)
    # Execute final liquidation with commission
    sale_proceeds = (shares * last_price) - commission
    balance += sale_proceeds
    sell_points.append((len(close) -1, close[-1] if close else 0.01)) # Record final auto-sell
    print(f"Final liquidation: Sold [shares] shares at [last_price:.2f] with [commission:.2f] commission")
    shares = 0
balance_over_time.append(balance) # Append final balance state
return balance - initial_balance, buy_points, sell_points, balance_over_time
```
**(Note:** The MANDATORY TRADING LOGIC above is a template. You **must** integrate it correctly within the `trading_strategy` function\'s loop, defining variables like `i`, `price_today`, `buy_price`, `sell_price` according to the user\'s strategy and the parameters from `get_user_params`. The comments indicate where your strategy-specific logic needs to fit.)

**Final Check:** Ensure your output is only the two raw Python function definitions separated by a single blank line. No markdown, no comments outside the functions, no extra text.

**Important Output Format Requirements:**
- Your trading_strategy function may return its results in EITHER of these formats:
  1. Standard tuple: (profit_loss, buy_points, sell_points, balance_over_time)
  2. Dictionary format: {\'profit_loss\': profit_amount, \'buy_points\': [...], \'sell_points\': [...], \'balance_over_time\': [...]}

- The dictionary format is preferred as it\'s more explicit. For buy_points and sell_points, you can provide either:
  * A list of (index, price) tuples
  * A list of indices where trades occurred


# --- Generated Strategy Function --- #
def trading_strategy(params):
    """
    Improved trend-following swing strategy with buffered triggers, trend filter, and partial allocation.
    """
    initial_balance = 100000
    balance = initial_balance
    shares = 0
    buy_points = []
    sell_points = []
    balance_over_time = [balance]

    slippage_pct = params.get('slippage_pct', 0.001)
    spread_pct = params.get('spread_pct', 0.0005)
    commission_per_share = params.get('commission_per_share', 0.005)
    min_commission_per_trade = params.get('min_commission', 1.0)
    max_position_pct_of_volume = params.get('max_position_pct', 0.01)
    fast_ma_period = params.get('fast_ma_period', 20)
    slow_ma_period = params.get('slow_ma_period', 200)
    rsi_period = params.get('rsi_period', 21)
    rsi_overbought = params.get('rsi_overbought', 75)
    rsi_oversold = params.get('rsi_oversold', 30)
    min_hold_days = params.get('min_hold_days', 20)
    buy_buffer = params.get('buy_buffer', 0.02)
    sell_buffer = params.get('sell_buffer', 0.02)
    base_position_pct = params.get('base_position_pct', 0.15)
    buy_price_multiplier = params.get('buy_price_multiplier', 0.995)
    sell_price_multiplier = params.get('sell_price_multiplier', 1.005)
    avg_volume = params.get('avg_volume', 100000)

    last_buy_idx = -min_hold_days - 1
    last_sell_idx = -min_hold_days - 1
    holding = False
    base_position = 0
    n = len(close)
    fast_ma = [None] * n
    slow_ma = [None] * n
    rsi = [None] * n

    # Compute moving averages
    for i in range(n):
        if i >= fast_ma_period - 1:
            fast_ma[i] = sum(close[i - fast_ma_period + 1:i + 1]) / fast_ma_period
        if i >= slow_ma_period - 1:
            slow_ma[i] = sum(close[i - slow_ma_period + 1:i + 1]) / slow_ma_period

    # Compute RSI
    for i in range(rsi_period, n):
        gains = 0.0
        losses = 0.0
        for j in range(i - rsi_period + 1, i + 1):
            diff = close[j] - close[j - 1]
            if diff > 0:
                gains += diff
            else:
                losses -= diff
        avg_gain = gains / rsi_period
        avg_loss = losses / rsi_period if losses != 0 else 1e-6
        rs = avg_gain / avg_loss
        rsi[i] = 100 - (100 / (1 + rs))

    for i, price_today in enumerate(close):
        can_buy = shares == 0 or shares <= int(base_position * 1.1)
        can_sell = shares > 0
        # Trend filter: price above slow MA
        trend_up = slow_ma[i] is not None and price_today > slow_ma[i]
        # Buy: Fast MA crosses above slow MA, RSI not overbought, price > slow MA + buffer, and not recently bought
        buy_signal = (
            i > slow_ma_period and
            fast_ma[i - 1] is not None and fast_ma[i - 2] is not None and
            fast_ma[i - 2] < slow_ma[i - 2] and fast_ma[i - 1] > slow_ma[i - 1] and
            rsi[i] is not None and rsi[i] < rsi_overbought and
            price_today > slow_ma[i] * (1 + buy_buffer) and
            trend_up and
            (i - last_buy_idx) >= min_hold_days
        )
        # Sell: Fast MA crosses below slow MA, RSI overbought, price < slow MA - buffer, and not recently sold
        sell_signal = (
            i > slow_ma_period and
            fast_ma[i - 1] is not None and fast_ma[i - 2] is not None and
            fast_ma[i - 2] > slow_ma[i - 2] and fast_ma[i - 1] < slow_ma[i - 1] and
            rsi[i] is not None and rsi[i] > rsi_overbought and
            price_today < slow_ma[i] * (1 - sell_buffer) and
            (i - last_sell_idx) >= min_hold_days
        )
        # Partial allocation: always hold base position if trend is up
        if can_buy and trend_up and shares == 0 and base_position_pct > 0:
            base_price = price_today * (1 + spread_pct)
            buy_price_with_spread = base_price * (1 + slippage_pct)
            buy_price = max(0.01, buy_price_with_spread * buy_price_multiplier)
            max_shares_by_volume = int(avg_volume * max_position_pct_of_volume)
            max_shares_by_cash = math.floor(balance / buy_price) if buy_price > 0 else 0
            base_shares = int(max_shares_by_cash * base_position_pct)
            shares_to_buy = min(base_shares, max_shares_by_volume)
            if shares_to_buy > 0:
                commission = max(min_commission_per_trade, shares_to_buy * commission_per_share)
                trade_cost = (shares_to_buy * buy_price) + commission
                if trade_cost <= balance:
                    balance -= trade_cost
                    shares += shares_to_buy
                    base_position = shares
                    buy_points.append((i, price_today))
                    last_buy_idx = i
        # Main buy logic
        elif buy_signal and can_buy:
            base_price = price_today * (1 + spread_pct)
            buy_price_with_spread = base_price * (1 + slippage_pct)
            buy_price = max(0.01, buy_price_with_spread * buy_price_multiplier)
            max_shares_by_volume = int(avg_volume * max_position_pct_of_volume)
            max_shares_by_cash = math.floor(balance / buy_price) if buy_price > 0 else 0
            shares_to_buy = min(max_shares_by_cash, max_shares_by_volume)
            if shares_to_buy > 0:
                commission = max(min_commission_per_trade, shares_to_buy * commission_per_share)
                trade_cost = (shares_to_buy * buy_price) + commission
                if trade_cost <= balance:
                    balance -= trade_cost
                    shares += shares_to_buy
                    buy_points.append((i, price_today))
                    last_buy_idx = i
        # Main sell logic
        elif sell_signal and can_sell and (i - last_buy_idx) >= min_hold_days:
            base_price = price_today * (1 - spread_pct)
            sell_price_with_spread = base_price * (1 - slippage_pct)
            sell_price = max(0.01, sell_price_with_spread * sell_price_multiplier)
            if shares > 0:
                commission = max(min_commission_per_trade, shares * commission_per_share)
                sale_proceeds = (shares * sell_price) - commission
                balance += sale_proceeds
                sell_points.append((i, price_today))
                shares = 0
                last_sell_idx = i
        balance_over_time.append(balance + (shares * price_today if shares > 0 else 0))
    if shares > 0:
        base_price = max(0.01, close[-1] if close else 0.01) * (1 - spread_pct)
        last_price = max(0.01, base_price * (1 - slippage_pct))
        commission = max(min_commission_per_trade, shares * commission_per_share)
        sale_proceeds = (shares * last_price) - commission
        balance += sale_proceeds
        sell_points.append((len(close) - 1, close[-1] if close else 0.01))
        shares = 0
    balance_over_time.append(balance)
    return {
        'profit_loss': balance - initial_balance,
        'buy_points': buy_points,
        'sell_points': sell_points,
        'balance_over_time': balance_over_time
    }

# --- Generated Parameters Function --- #
def get_user_params():
    """
    Returns improved, less overfit parameters for trend-following swing strategy.
    """
    params = {
        'slippage_pct': 0.001,
        'spread_pct': 0.0005,
        'commission_per_share': 0.005,
        'min_commission': 1.0,
        'max_position_pct': 0.02,  # Allow up to 2% of daily volume
        'fast_ma_period': 20,      # Longer-term fast MA
        'slow_ma_period': 200,     # Classic trend filter
        'rsi_period': 21,          # Standard RSI
        'rsi_overbought': 75,      # Higher threshold to avoid premature exits
        'rsi_oversold': 30,
        'min_hold_days': 20,       # Hold longer to capture trends
        'buy_buffer': 0.02,        # Require 2% move above slow MA to buy
        'sell_buffer': 0.02,       # Require 2% move below slow MA to sell
        'base_position_pct': 0.15, # Always hold 15% base position in uptrend
        'buy_price_multiplier': 0.995, # Slightly improve fill price
        'sell_price_multiplier': 1.005,
        'avg_volume': 100000
    }
    return params