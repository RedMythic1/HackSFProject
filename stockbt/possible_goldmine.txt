def trading_strategy(params):
    """
    Implements a strategy using a weighted sum of 1st, 2nd, 3rd... nth order backward derivatives of price,
    applying an exponential weight decay for higher-order derivatives.
    Params:
        'deriv_order': max derivative order to include (int)
        'deriv_decay': decay rate for weight (float <1)
        'buy_thresh': threshold for buy signal (float)
        'sell_thresh': threshold for sell signal (float)
        'buy_mult': multiplier to price for buy execution (float)
        'sell_mult': multiplier to price for sell execution (float)
    """
    initial_balance = 100000
    balance = initial_balance
    shares = 0
    end_price = 0
    buy_points = []
    sell_points = []
    balance_over_time = [balance]
    max_order = int(params.get('deriv_order', 3))
    decay = float(params.get('deriv_decay', 0.5))
    buy_thresh = float(params.get('buy_thresh', 0.5))
    sell_thresh = float(params.get('sell_thresh', -0.5))
    buy_mult = float(params.get('buy_mult', 1))
    sell_mult = float(params.get('sell_mult', 1))
    prev_values = []
    for i, price_today in enumerate(close):
        prev_values.append(price_today)
        if i == 0:
            # Not enough data for derivatives
            balance_over_time.append(balance)
            continue
        derivs = []
        base = list(prev_values)
        for order in range(1, max_order + 1):
            if len(base) < 2:
                break
            diff = [base[j] - base[j - 1] for j in range(1, len(base))]
            derivs.append(diff[-1])
            base = diff
        weights = [decay ** k for k in range(len(derivs))]
        # Compose the weighted sum
        weighted_sum = sum([derivs[k] * weights[k] for k in range(len(derivs))])
        buy_signal = weighted_sum >= buy_thresh
        sell_signal = weighted_sum <= sell_thresh
        if buy_signal:
            buy_price = price_today * buy_mult
            try:
                shares_to_buy = math.floor(balance / buy_price)
            except Exception:
                shares_to_buy = 0
            if shares_to_buy > 0:
                balance -= shares_to_buy * buy_price
                shares += shares_to_buy
                buy_points.append((i, price_today))
        if sell_signal:
            if shares > 0:
                sell_price = price_today * sell_mult
                balance += shares * sell_price
                sell_points.append((i, price_today))
                shares = 0
        balance_over_time.append(balance)
    if shares > 0:
        final_price = close[-1] if close else 0
        balance += shares * final_price
        shares = 0
    balance_over_time.append(balance)
    return balance - initial_balance, buy_points, sell_points, balance_over_time

def get_user_params():
    # Parameters chosen heuristically for typical price scale and volatility;
    # deriv_decay < 1 dampens higher-order derivatives; thresholds are relative;
    # multipliers avoid using absolute prices.
    params = {
        'deriv_order': 3,
        'deriv_decay': 0.6,
        'buy_thresh': 0.4,
        'sell_thresh': -0.35,
        'buy_mult': 0.999,
        'sell_mult': 1.001
    }
    return params