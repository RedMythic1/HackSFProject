{"version":3,"sources":["../src/index.ts","../src/copy.ts"],"sourcesContent":["// When bundled via a bundler supporting the `browser` field, then\n// the `undici` module will be replaced with https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n// for browser contexts. See ./undici-browser.js and ./package.json\nimport { fetch } from 'undici';\nimport type { BlobCommandOptions } from './helpers';\nimport {\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\nimport type { PutCommandOptions } from './put';\nimport { createPutMethod } from './put';\n\n// expose the BlobError types\nexport {\n  BlobAccessError,\n  BlobError,\n  BlobNotFoundError,\n  BlobStoreNotFoundError,\n  BlobStoreSuspendedError,\n  BlobUnknownError,\n} from './helpers';\nexport type { PutBlobResult } from './put';\n\n/**\n * Uploads a blob into your store from your server.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#upload-a-blob\n *\n * If you want to upload from the browser directly, check out the documentation for client uploads: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#client-uploads\n *\n * @param pathname - The pathname to upload the blob to. This includes the filename.\n * @param body - The contents of your blob. This has to be a supported fetch body type https://developer.mozilla.org/en-US/docs/Web/API/fetch#body.\n * @param options - Additional options like `token` or `contentType`.\n */\nexport const put = createPutMethod<PutCommandOptions>({\n  allowedOptions: ['cacheControlMaxAge', 'addRandomSuffix', 'contentType'],\n});\n\n// vercelBlob.del()\n\ntype DeleteBlobApiResponse = null;\n\n/**\n * Deletes one or multiple blobs from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#delete-a-blob\n *\n * @param url - Blob url or array of blob urls that identify the blobs to be deleted. You can only delete blobs that are located in a store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param options - Additional options for the request.\n */\nexport async function del(\n  url: string[] | string,\n  options?: BlobCommandOptions\n): Promise<void> {\n  const blobApiResponse = await fetch(getApiUrl('/delete'), {\n    method: 'POST',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n      'content-type': 'application/json',\n    },\n    body: JSON.stringify({ urls: Array.isArray(url) ? url : [url] }),\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  (await blobApiResponse.json()) as DeleteBlobApiResponse;\n}\n\n// vercelBlob.head()\n\nexport interface HeadBlobResult {\n  url: string;\n  size: number;\n  uploadedAt: Date;\n  pathname: string;\n  contentType: string;\n  contentDisposition: string;\n  cacheControl: string;\n}\n\ninterface HeadBlobApiResponse extends Omit<HeadBlobResult, 'uploadedAt'> {\n  uploadedAt: string; // when receiving data from our API, uploadedAt is a string\n}\n\n/**\n * Fetches metadata of a blob object.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#get-blob-metadata\n *\n * @param url - Blob url to lookup.\n * @param options - Additional options for the request.\n */\nexport async function head(\n  url: string,\n  options?: BlobCommandOptions\n): Promise<HeadBlobResult> {\n  const headApiUrl = new URL(getApiUrl());\n  headApiUrl.searchParams.set('url', url);\n\n  const blobApiResponse = await fetch(headApiUrl, {\n    method: 'GET', // HEAD can't have body as a response, so we use GET\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n    },\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  const headResult = (await blobApiResponse.json()) as HeadBlobApiResponse;\n\n  return mapBlobResult(headResult);\n}\n\n// vercelBlob.list()\nexport interface ListBlobResultBlob {\n  url: string;\n  pathname: string;\n  size: number;\n  uploadedAt: Date;\n}\n\nexport interface ListBlobResult {\n  blobs: ListBlobResultBlob[];\n  cursor?: string;\n  hasMore: boolean;\n}\n\ninterface ListBlobApiResponseBlob\n  extends Omit<ListBlobResultBlob, 'uploadedAt'> {\n  uploadedAt: string;\n}\n\ninterface ListBlobApiResponse extends Omit<ListBlobResult, 'blobs'> {\n  blobs: ListBlobApiResponseBlob[];\n}\n\nexport interface ListCommandOptions extends BlobCommandOptions {\n  /**\n   * The maximum number of blobs to return.\n   * @defaultvalue 1000\n   */\n  limit?: number;\n  /**\n   * Filters the result to only include blobs located in a certain folder inside your store.\n   */\n  prefix?: string;\n  /**\n   * The cursor to use for pagination. Can be obtained from the response of a previous `list` request.\n   */\n  cursor?: string;\n}\n\n/**\n * Fetches a paginated list of blob objects from your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#list-blobs\n *\n * @param options - Additional options for the request.\n */\nexport async function list(\n  options?: ListCommandOptions\n): Promise<ListBlobResult> {\n  const listApiUrl = new URL(getApiUrl());\n  if (options?.limit) {\n    listApiUrl.searchParams.set('limit', options.limit.toString());\n  }\n  if (options?.prefix) {\n    listApiUrl.searchParams.set('prefix', options.prefix);\n  }\n  if (options?.cursor) {\n    listApiUrl.searchParams.set('cursor', options.cursor);\n  }\n  const blobApiResponse = await fetch(listApiUrl, {\n    method: 'GET',\n    headers: {\n      ...getApiVersionHeader(),\n      authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n    },\n  });\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  const results = (await blobApiResponse.json()) as ListBlobApiResponse;\n\n  return {\n    ...results,\n    blobs: results.blobs.map(mapBlobResult),\n  };\n}\n\nfunction mapBlobResult(blobResult: HeadBlobApiResponse): HeadBlobResult;\nfunction mapBlobResult(blobResult: ListBlobApiResponseBlob): ListBlobResultBlob;\nfunction mapBlobResult(\n  blobResult: ListBlobApiResponseBlob | HeadBlobApiResponse\n): ListBlobResultBlob | HeadBlobResult {\n  return {\n    ...blobResult,\n    uploadedAt: new Date(blobResult.uploadedAt),\n  };\n}\n\n// vercelBlob.copy()\n\nexport { copy, type CopyBlobResult } from './copy';\n","import { fetch } from 'undici';\nimport type { CreateBlobCommandOptions } from './helpers';\nimport {\n  BlobError,\n  getApiUrl,\n  getApiVersionHeader,\n  getTokenFromOptionsOrEnv,\n  validateBlobApiResponse,\n} from './helpers';\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface -- expose option interface for each API method for better extensibility in the future\nexport interface CopyCommandOptions extends CreateBlobCommandOptions {}\n\nexport interface CopyBlobResult {\n  url: string;\n  pathname: string;\n  contentType?: string;\n  contentDisposition: string;\n}\n\n/**\n * Copies a blob to another location in your store.\n * Detailed documentation can be found here: https://vercel.com/docs/storage/vercel-blob/using-blob-sdk#copy-a-blob\n *\n * @param fromUrl - The blob URL to copy. You can only copy blobs that are in the store, that your 'BLOB_READ_WRITE_TOKEN' has access to.\n * @param toPathname - The pathname to copy the blob to. This includes the filename.\n * @param options - Additional options. The copy method will not preserve any metadata configuration (e.g.: 'cacheControlMaxAge') of the source blob. If you want to copy the metadata, you need to define it here again.\n */\nexport async function copy(\n  fromUrl: string,\n  toPathname: string,\n  options: CopyCommandOptions\n): Promise<CopyBlobResult> {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (!options) {\n    throw new BlobError('missing options, see usage');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Runtime check for DX.\n  if (options.access !== 'public') {\n    throw new BlobError('access must be \"public\"');\n  }\n\n  const headers: Record<string, string> = {\n    ...getApiVersionHeader(),\n    authorization: `Bearer ${getTokenFromOptionsOrEnv(options)}`,\n  };\n\n  if (options.addRandomSuffix !== undefined) {\n    headers['x-add-random-suffix'] = options.addRandomSuffix ? '1' : '0';\n  }\n\n  if (options.contentType) {\n    headers['x-content-type'] = options.contentType;\n  }\n\n  if (options.cacheControlMaxAge !== undefined) {\n    headers['x-cache-control-max-age'] = options.cacheControlMaxAge.toString();\n  }\n\n  const blobApiResponse = await fetch(\n    getApiUrl(`/${toPathname}?fromUrl=${fromUrl}`),\n    { method: 'PUT', headers }\n  );\n\n  await validateBlobApiResponse(blobApiResponse);\n\n  return (await blobApiResponse.json()) as CopyBlobResult;\n}\n"],"mappings":"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","names":["fetch","fetch"]}